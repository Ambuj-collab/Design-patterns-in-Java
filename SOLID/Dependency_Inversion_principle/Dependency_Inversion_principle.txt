1) Let's look at the formal definition of this principle. Now, this principle comes in two different parts. 
	a) The first part states that high level modules should not depend on low level modules. Both should depend on abstraction.
	b) The second part of the principle tells us that abstractions should not depend on details. Rather, details should depend on abstractions.
	
2) One of the biggest problems that I see in newcomers when understanding this principle is that they really don't know what dependency actually is. So I will try to explain what a dependency is in a very simple terms. This is not the formal definition of dependency but this is something that will help you visualize when you are understanding dependency inversion principle. So what is the dependency? Let's say I'm writing a code and I want to print something on console. How do we do it in Java? Well, we use System.out.println() and we give it a string. So now my code actually has a dependency on the "out" object that is defined in the System class because I'm using the println() method of the "out" object. So "out" object is my dependency.

	public void printMe() {
		System.out.println("Hello");
	}
	
3) Let's take it a little bit further. Let's say we are writing a method that will generate a report in, let's say, Json format, and let's say this function will write that report on disk. So the below is the function that we are writing. So what are the dependencies for this particular function now? Well, we, first of all, need something, some object, some module, that will take our report object and will convert it to Json. So that particular object(object of JSONFormatter class i.e., formatter) is our dependency. Then we need something which actually takes that Json string and writes onto the disk. That could be our FileWriter class from java.io package. So that is again another dependency of this particular function.

	public void writeReport() {
		Report report = new Report();
		//Build the report
		JSONFormatter formatter = new JSONFormatter();
		String report = formatter.format(report);
		FileWriter writer = new FileWriter("report.json");
		//write out report
	}
	
All right, so now you understand what dependency is. So dependency is something that we need in order to provide the functionality that we are writing code for.

4) Now, when we are saying dependency inversion, it is telling us to do something that is opposite to what we typically do. So what do we do?
Let's take this report generation method[writeReport()] here again, as shown above. What will you typically do if you are writing this particular function? Well, we will create an object of file writer. We'll create another object that will allow us to convert our Java object to Json(JSONFormatter). So we are instantiating these objects in our method and that's why we are tightly coupling our report generation method[writeReport()] to these particular implementations[JSONFormatter and FileWriter]. So if somebody comes and tells us we like the report but we want it in HTML format, what are we going to do? We are going to go into our report generation method[writeReport()] and modify the code. What if somebody says, you know, you are writing on a disk that is not really good, We want to send that report to a different server. Why don't you just post whatever report that you generate, post that whole string to this particular URL? What are you going to do? You are going to modify your existing report generation method[writeReport()]. And once you start messing around with code that is already written and tested, you are going to introduce or you are creating a possibility to create more bugs or defects and dependencies. Dependency Inversion principle is telling us how to solve this particular problem. Dependency inversion principle is telling us that instead of tightly coupling our high level module, high level module basically means a module that provides or that implements some business rules. That is the high level module. That is what we write[writeReport()]. A low level module is basically a functionality that is so basic that it can be used anywhere. For example, writing to disk is something that can be used anywhere. Converting Java object to Json, this is again a low level functionality that can be used at multiple places. So now our high level module should not depend on low level modules. So now you understand what this principle is telling us. It is telling us that we should not tightly coupled with these concrete classes. And what else it is telling us, it tells us that both should depend on abstraction. So what is an abstraction for us? It could be as simple as an interface.

5) So instead of creating a new instance of Object Mapper[JSONFormatter] or creating new instance of file writer[FileWriter], we can use an interface called as, let's say, Writer, another interface called as Formatter. And we will write our high level module code using that interface. So instead of creating a new object in our method[writeReport()], we will accept parameters of these particular interfaces. And we will write our entire code using those interfaces. And the benefit is that our code is no longer tightly coupled to any concrete class. Anybody who wants to generate a report, let's say he wants an HTML report, then he will pass us a different implementation of formatter and he will get HTML report. If somebody wants it in XML format, he will give us XML format or implementation and the method will generate XML report. So this is what dependency inversion allows us to do. It tells us that instead of instantiating dependencies ourselves, let somebody else give us the dependencies and this is what dependency inversion is. We are not creating new instances in our high level module. Somebody else is creating for us and giving those to us. So this is what dependency inversion principle is.

	public void writeReport (Formatter formatter, Writer writer) {
		Report report = new Report();
		//Build the report
		String report = formatter.format(report);
		//write out report
		writer.write("myreport");
	}
	
6) All right, Now let's see the dependency inversion principle in action using some Java code. So we have a class here called as message printer. It's a simple class with a method called as write message. And the idea here is that this method will get a message object. And right now it is also receiving a file name. And this class will basically print the message object by first converting it to a Json format and then writing that Json message to the file with the given name and it is using print writer to do actual file writing. So if we come to our main() method here, we have we are creating a message object and then we are creating the message printer object and calling the write message. We are passing the message object here and the file name. So if we run this code right now, you will see that it completes its run and then it creates a file, at the base location of the project, that you see here. 

7) Just to be complete, I will quickly show you all the classes that are participating here. We have a message class here. It is simple class. It has a string which stores the actual message content. It has a timestamp property as well and it is initialized with the current time as soon as the message object is created. We have some getter methods here. Then we have Json formatter and it is implementing a formatter interface. Formatter interface is simple interface that has a format method and Json formatter implements that method. Here and it is using the Jackson library in order to carry out the Json serialization(converting Java object to Json). And as you can see, the dependencies for the write message method[writeMessage()] that we can immediately find out is that it depends on the Json formatter and it depends on the print writer. Now this print writer is part of the Java's io package, but nonetheless, this is a dependency of this particular write message method. 

8) Now what are the problems or what are the issues with the current implementation? Well, let's say if we want to print this message on console, then the current method[writeMessage()] is not going to work unless we go and write another method where instead of using print writer, we use "System.out". That is the first problem. Second problem is that if we want to change the format of the message, then we have to again modify this particular method[writeMessage()] and change the Json formatter to the new class that we want to use to format our message object. So these are the problems in traditional software development methodology that we have because we have to know about these concrete classes and that creates a tight coupling between our method[writeMessage()] i.e., our code[writeMessage()] and these objects. Dependency inversion will allow us to remove this dependency. So our write message[writeMessage()] should not ideally be tightly coupled with Json formatter. It can depend on abstraction. So what is an abstraction here? Formatter which is an interface, is an abstraction. And if we depend on this abstraction, then we can change the object that is actually used without needing to modify this code[writeMessage()]. So how can we do that? Well, to do that, we have to change how we write our or how we implement our method. So instead of creating an object of Json formatter here, what I'm going to do is I'm going to accept Formatter as a method parameter, and you can guess, We can also accept Printwriter as a method parameter too. We don't even need to close the printwriter in writeMessage(). So now instead of creating the Json formatter, we are accepting a parameter. So we are declaring our dependency and we're asking our caller to give us the dependency. So somebody else is now giving dependency to this method, and that is the inversion now. So the responsibility of creating the actual object of the dependency is now with the client or caller of this write message[writeMessage()]. So if we come back to main() method now, instead of simply passing the message, we also need to pass the actual formatter and we also need to pass the object of print writer. In the client code now, instead of simply calling the method[writeMessage()], we have to provide the dependencies for this particular method[writeMessage()]. So our method[writeMessage()] now contains only the business rules/logic. So this is how we use dependency inversion. And the benefit of this is that instead of passing object of print writer, maybe we can pass something like "System.out". Now if we run our code as Java application, you will see that we get our message on console. So this is the power of dependency inversion. 

9) Actually, once you see how easy it is to change the actual objects that are used by our write message method[writeMessage()] or the original method, you will see the power behind the dependency inversion. We didn't need to modify our write message method[writeMethod()]. You can implement this method[writeMethod()], test it once and then you can keep it aside. And we can change the objects or the dependencies that we are supplying to this particular method[writeMethod()] and we can get different type of behavior or different kind of output. On the similar lines, we can also change our formatter to something like a text formatter and we will get message in the text format. So this is how dependency inversion principle is implemented and this is how it helps us.

10) It's a really powerful mechanism and if you are using something like spring or spring boot, you are already making use of dependency inversion, the auto wiring that happens, the spring beans, those are all utilizing the dependency inversion principle.