1) This is the third principle from the Solid Design Principles Group. Now, this principle states that we should be able to use subclass or child class object wherever base class object is expected. And this substitution should not alter desired properties of the program.

2) That means if the base class object was providing a specific behavior and if that base class object is now substituted with a child class object, that behavior should not alter. Okay, so what is expected to happen in that particular code should happen even if we change the base class object with the child class object.

3) All right, Now let's look at a Java example that will explain Liskov substitution principle to you in detail. And once you go through this example, you will be absolutely clear on Liskov substitution. Now, I typically do not use classes like rectangle, shape and animals to explain design patterns and principles. I try to use classes which at least have same context as real life application. Of course, I cannot have a full application for each and every pattern, but I try to have classes which you will find in real life applications. But when it comes to Liskov substitution, I am going to use Rectangle and Square because this is a very classic example that is used in context with Liskov substitution. In fact, if you google liskov substitution, you will come across this example. You will find it in books.

4) Now before we begin, we already know what a rectangle is from our geometry class in school. Rectangle is a polygon with four sides. It has a width and height, so it has two sides that are equal to each other. And we also know that square again is a polygon with four sides and all of its sides are of same length. So we know that square is a special type of rectangle. So if we make width and height of a rectangle of same value, then we will get a square. So it makes perfect sense for us that a square is a rectangle. Now if we translate that idea into our Java code, we'll end up with code that looks something like this.

5) So we have a class here called as Rectangle. It has two properties, width and height. We have a constructor that takes two values and sets the width and height according to those parameters. We have getter setter method here for width and height. And lastly, we have a compute area method that returns area of that rectangle. Fairly simple class, nothing complicated here. Then we have a square class and we know that square is a rectangle. So our square class is extending from our rectangle class, but Square has all of its sides of same length. So that's why our square constructor takes only a single parameter and it passes on to the rectangle constructor. The same value for width as well as height. Now, when we are writing the square class as a child class of rectangle, we need to take care of set width and set height method. Right? Because if somebody sets width of our square to some value, then we need to make sure that our height is also of same value because then only it is going to remain a square. You cannot have width and height of different values for a square. So that is why you will see that I have overridden set width and set height method and I'm calling a set side method which is new in this class. Set side method takes a single value and sets width and height equal to that passed value. We are just making sure that our square remains a square if somebody sets width or height individually. Okay, so this is how we will implement a square that is a rectangle. And so far so good. There doesn't seem to be any problem here. Now let's move on to the next class. This is a simple class with a main method here. And if you look at the code, we are creating a rectangle here. Then we are creating a square. We are printing the area of a rectangle as well as an area. And then we are calling a method called as use rectangle. Now this method accepts a parameter of type rectangle. So that is why we are able to pass Square to this method because remember, square is a rectangle, it is a child class of rectangle. And in this method a code is written that sets height and width of a rectangle to some value, and it makes sure that those values are actually set in that rectangle object. Before we run this code, enable assertion on Eclipse by passing -ea to VM arguments. You can use even a if else statement here to get the same result, instead of assertion. So we are asserting that when we set our rectangle height to 20, we are going to get that 20 back. When we are say saying setting the width of a rectangle to 30. We are going to get the same value back. This is a simple test case as you can see, but if we run this test, you will see that our square fails this particular test. Why? Because as you can see, once we set height of a square, let's go to the overridden method. We are setting width and height to 20 because it is a square. And then we set width to 30. That means again, our set side method is getting called and it is going to set width as well as height to 30. Okay, so now you see how this particular test is failing. If we pass this method a square, which is a child class of our rectangle. And this is what Liskov substitution is all about, because here we can see that even though technically we are a valid child class because we have done all the necessary things syntactically, we have modified the behavior that is expected of the base class. Okay, so whenever somebody wrote set height and set width method of a rectangle class, they set some contract that whenever you set a width and you call get width, you will get the same value back. If you set height and call get height, you will get the same height back. And when we overrode or when we extended from that class and overrode these two methods, we violated that defined behavior. And that is why we see that this particular example is violation of liskov substitution principle. 

6) Okay, so how do you fix this type of a problem? How do you fix this particular example? How will you fix it? Well, the only way to do that is that we need to break this relationship because even though geometrically or mathematically it makes sense, that square is a rectangle when it comes to object oriented programming, that relationship is not really valid because it violates our contract of set height and set width method of rectangle class. So in order to solve this problem, what we can do is we can create an interface called as shape. Okay, so this shape interface will only have common behavior defined inside it. So we will only have something like compute area method sorry, compute area method in this interface and Our rectangle can implement the shape interface and our square, instead of extending from a rectangle, will implement shape. So this is how now we have two classes rectangle and square that do not have a direct relationship, but they both implement same interface called as shape. And this is how we can avoid violating the liskov substitution principle. Okay, so now the use rectangle method. We can write another test case that test the square separately. Because we we are now making sure that anyone who is using our square is not under impression that he is using a special type of rectangle.